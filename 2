import GET_SEARCH_ENGINE_SYNONYMS from "graphQL/getSearchEngineSynonyms";
import { immutableSplice } from "utils";
import Alert from "react-s-alert";
import { client, maxIntentsNumber } from "configs/mainConfig";
import { C } from "constants";

// *********
// validator
// *********
export const validateMasterWordExpression = (expression, allMasterWords) => {
	// not empty
	if (expression.replace(/ /g, "") === "") {
		return { valid: false, msg: __("EmptyText") };
	}
	// not already in a group
	const found = allMasterWords && allMasterWords.find(
		(sg) => sg.masterWord === expression
			|| (sg.synonyms && JSON.parse(sg.synonyms)
			.map((e) => e.synonym)
			.find((el) => el === expression))
	);
	if (found) {
		return {
			valid: false,
			msg: `${__("ExpressionAlreadyExists")} ${found.masterWord}`
		};
	}

	return { valid: true };
};

export const validateSynonymExpression = (expression, masterWord) => {
	console.log("expression in validateSynonymExpression:", expression);
	console.log("masterWord in validateSynonymExpression:", masterWord);

	// not empty
	if (expression.replace(/ /g, "") === "") {
		return { valid: false, msg: __("EmptyText") };
	}
	// not already in a group
	const found = (masterWord.synonyms && masterWord.synonyms.find((el) => el === expression));
	if (found) {
		return {
			valid: false,
			msg: `${__("ExpressionAlreadyExists")} ${found.masterWord}`
		};
	}

	return { valid: true };
};

// ********************************
// Manipulation of cache and remote
// ********************************

/*
* use for generating a new array by inserting n (here is 1)
* element without changing the orignal array
* notice:n equal 0 means deletion
* */
export const prepareDataToInsertInCache = (data, oldObject, newObject) => {
	const oldObjIndex = data.map((item) => item.id).indexOf(oldObject.id);
	return immutableSplice(data, oldObjIndex, 1, newObject);
};

export const getSynonymGroupsFromApolloCache = (apolloCache, variables) => apolloCache.readQuery({
	query: GET_SEARCH_ENGINE_SYNONYMS,
	variables
});

export const getItemsFromCache = (variables) => client.readQuery({
	query: GET_SEARCH_ENGINE_SYNONYMS,
	variables
});

export const getItemFromCache = (variables, id, projectName) => {
	const { getSearchEngineSynonyms } = client.readQuery({
		query: GET_SEARCH_ENGINE_SYNONYMS,
		variables
	});
	const items = getSearchEngineSynonyms;
	const findItem = items.filter((e) => e.id === id && e.projectName === projectName);
	const item = findItem.length > 0
		? findItem
		: items.filter((e) => e.id === id && e.projectName === "defaultDataProject");
	const result = item.length > 0 ? findItem[0] : null;
	return result;
};

export const updateItemToCache = ({
	variables, id, projectName, attribute, value
}) => {
	const data = getItemsFromCache(variables);
	const { getSearchEngineSynonyms } = data;
	const oldItem = getItemFromCache(variables, id, projectName);
	const newItem = {
		...oldItem,
		projectName,
		[attribute]: value
	};
	const dataToInsert = prepareDataToInsertInCache(getSearchEngineSynonyms, oldItem, newItem);
	client.writeQuery({
		query: GET_SEARCH_ENGINE_SYNONYMS,
		variables,
		data: {
			getSearchEngineSynonyms: dataToInsert
		}
	});
};

export const createVariables = ({
	id, projectName, currentProject, attribute, value, lang, variables, syn
}) => {
	const oldItem = getItemFromCache(variables, id, projectName);

	if (currentProject === projectName) {
		return {
			id,
			projectName,
			attribute,
			value: syn ? oldItem.synonyms : value,
			lang
		};
	}
	return {
		...oldItem,
		projectName: currentProject,
		lang
	};
};

export const updateItemToDB = ({
	id, projectName, currentProject,
	mutation, attribute, value, lang,
	vars, syn
}) => {
	const variables = createVariables({
		id,
		projectName,
		currentProject,
		attribute,
		value,
		lang,
		syn,
		variables: vars
	});
	mutation({
		variables
	});
};

export const updateSynItemToDB = ({
	id, projectName, currentProject,
	mutation, attribute, value, lang,
	vars
}) => {
	const variables = createVariables({
		id,
		projectName,
		currentProject,
		attribute,
		value,
		lang,
		variables: vars
	});
	mutation({
		variables
	});
};

export const synonymProcessing = ({
	synonyms, oldSynonym, newSynonym, action
}) => {
	if (action === C.DELETE) {
		return synonyms.reduce((acc, curr) => {
			if (curr.synonym !== oldSynonym) { return [ ...acc, curr ]; }
			return [ ...acc ];
		}, []);
	} if (action === C.ADD) {
		return [ ...synonyms, {
			synonym: newSynonym
		} ];
	} if (action === C.UPDATE) {
		return synonyms.reduce((acc, curr) => {
			if (curr.synonym !== oldSynonym) { return [ ...acc, curr ]; }
			return [ ...acc, { synonym: newSynonym } ];
		}, []);
	}
	return [];
};

// ACTION: {DELETE, ADD, UPDATE}
export const updateSynonymToCache = ({
	variables, id, projectName, oldSynonym, newSynonym, action
}) => {
	const data = getItemsFromCache(variables);
	const { getSearchEngineSynonyms } = data;
	const oldItem = getItemFromCache(variables, id, projectName);
	const synonyms = oldItem && oldItem.synonyms
		? JSON.parse(oldItem.synonyms)
		: [];
	const value = synonymProcessing({
		synonyms, oldSynonym, newSynonym, action
	});

	const newItem = {
		...oldItem,
		projectName,
		synonyms: JSON.stringify(value)
	};
	const dataToInsert = prepareDataToInsertInCache(getSearchEngineSynonyms, oldItem, newItem);
	client.writeQuery({
		query: GET_SEARCH_ENGINE_SYNONYMS,
		variables,
		data: {
			getSearchEngineSynonyms: dataToInsert
		}
	});
};

/*
* promote btn func
* */
export const promoteToCache = ({
	variables, id, projectName, synonym,
	currentProject, add, update, lang
}) => {
	const data = getItemsFromCache(variables);
	const { getSearchEngineSynonyms } = data;
	const oldItem = getItemFromCache(variables, id, projectName);
	const synonyms = oldItem && oldItem.synonyms
		? JSON.parse(oldItem.synonyms)
		: [];
	const value = synonymProcessing({
		synonyms, oldSynonym: synonym, newSynonym: oldItem.masterWord, action: C.UPDATE
	});

	const newItem = {
		...oldItem,
		masterWord: synonym,
		projectName: currentProject,
		synonyms: JSON.stringify(value)
	};
	const dataToInsert = prepareDataToInsertInCache(getSearchEngineSynonyms, oldItem, newItem);
	client.writeQuery({
		query: GET_SEARCH_ENGINE_SYNONYMS,
		variables,
		data: {
			getSearchEngineSynonyms: dataToInsert
		}
	});
	if (currentProject === projectName) {
		const vars = {
			id,
			projectName,
			lang
		};
		update({
			variables: {
				...vars,
				attribute: "masterWord",
				value: newItem.masterWord
			}
		});
		update({
			variables: {
				...vars,
				attribute: "synonyms",
				value: newItem.synonyms
			}
		});
	} else {
		add({
			variables: {
				...newItem,
				lang
			}
		});
	}
};

export const deleteItemFromCache = (variables, item) => {
	const data = getItemsFromCache(variables);
	const { getSearchEngineSynonyms } = data;
	const dataToInsert = getSearchEngineSynonyms
	.filter((e) => e.id !== item.id);
	console.log("DATA TO INSERT: ", dataToInsert);
	client.writeQuery({
		query: GET_SEARCH_ENGINE_SYNONYMS,
		variables,
		data: {
			getSearchEngineSynonyms: dataToInsert
		}
	});
};

export const modifySynonymGroupsInApolloCache = (apolloCache, variables, data) => {
	apolloCache.writeQuery({
		query: GET_SEARCH_ENGINE_SYNONYMS,
		variables,
		data
	});
};

export const mutationWithCacheUpdate = ({
	mutation,
	variables,
	items,
	query
}) => {
	mutation({
		variables,
		update: (proxy) => {
			const data = getSynonymGroupsFromApolloCache(proxy, query);
			const { getSearchEngineSynonyms } = data;
			const { oldItem, newItem } = items;
			const dataToInsert = prepareDataToInsertInCache(getSearchEngineSynonyms, oldItem, newItem);
			modifySynonymGroupsInApolloCache(proxy, query, {
				getSearchEngineSynonyms: dataToInsert
			});
		}
	});
};

export const createSynonymGroup = (mutation, variables, searchEngineSynonyms, GET_QUERY_VARS) => {
	const validation = validateMasterWordExpression(variables.masterWord, searchEngineSynonyms);
	if (!validation.valid) {
		Alert.error(validation.msg);
		return;
	}
	mutation({
		variables,
		update: (proxy, { data: { addSearchEngineSynonyms } }) => {
			const data1 = getSynonymGroupsFromApolloCache(proxy, GET_QUERY_VARS);
			const { getSearchEngineSynonyms } = data1;
			modifySynonymGroupsInApolloCache(proxy, GET_QUERY_VARS, {
				getSearchEngineSynonyms: [ ...getSearchEngineSynonyms, addSearchEngineSynonyms ]
			});
		}
	});
};

export const removeSynonymGroup = (
	mutation, masterWord, GET_QUERY_VARS, _closePopin
) => () => {
	mutation({
		variables: {
			id: masterWord.id,
			projectName: masterWord.projectName
		}

	});
	deleteItemFromCache(GET_QUERY_VARS, masterWord);

	_closePopin();
};

// ***************
// other functions
// ***************

// Search func in master word list
export const applySearch = (_synonymGroups, searchExpression) => searchExpression === ""
	? _synonymGroups
	: _synonymGroups.filter(
		(sg) => {
			const includedInMW = sg.masterWord.includes(searchExpression);
			const synonyms = sg.synonyms ? JSON.parse(sg.synonyms).map((e) => e.synonym) : [];
			const includedInSyns = synonyms.some((syn) => syn.includes(searchExpression));
			return includedInMW || includedInSyns;
		}
	);

// return start and end to pagination
export const getStartAndEnd = (newIndex) => {
	const start = newIndex * maxIntentsNumber;
	const end = newIndex * maxIntentsNumber + maxIntentsNumber;
	return [ start, end ];
};

// return totalPagination / totalCurentNumber / totalNumber to pagination
export const getPaginationInfo = (displaySearchEngineSynonymData, currentMasterWords) => {
	const totalPagination = Math.ceil(
		displaySearchEngineSynonymData
		&& displaySearchEngineSynonymData.length / maxIntentsNumber
	);

	const totalCurentNumber = currentMasterWords
		&& currentMasterWords.length;

	const totalNumber = displaySearchEngineSynonymData
		&& displaySearchEngineSynonymData.length;

	return [ totalPagination, totalCurentNumber, totalNumber ];
};

// extract id from each object in seachEngineSynonyms and form a new id array
export const extractObjArrPropstoIdArr = (arr) => arr && arr.reduce(
	(acc, cur) => [ ...acc, cur.id ], []
);

// extract master word from each object in seachEngineSynonyms and form a new id array
export const extractObjArrPropstoMasterWordArr = (arr) => arr && arr.reduce(
	(acc, cur) => [ ...acc, cur.masterWord ], []
);

// get remaining synonym nums when exceed specified limit show in left content
export const getRemainSynNum = (toTalSynonymNum, displaySynonymNum) => (
	toTalSynonymNum
		&& toTalSynonymNum > displaySynonymNum
		? toTalSynonymNum - displaySynonymNum
		: toTalSynonymNum
);
